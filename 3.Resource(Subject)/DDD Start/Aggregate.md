복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 Aggregate이다.

Aggregate
- 관련된 객체를 하나로 군으로 묶어준다.
- Aggregate를 통해서 복잡한 객체간의 관계를 쉽게 파악할 수 있다.
- 일관성을 관리하는 기준이 된다. 일관성을 관리하기 떄문에 복잡한 도메인을 단순한 구조로 만들어 준다.
	- 데이터를 갱신할 때 A 애그리거트와 B 애그리거트의 규칙이 같다.
- 데이터 일관성을 관리해준다.
- 관련된 모델을 하나로 모은 것이기 떄문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
	- 주문 애그리거트를 만들려면 Order, OrderLine, Orderer와 같은 관련 객체를 함께 생성해야 한다.
	- Order는 생성했는데 ShippingInfo는 만들지 않았거나 ShippingInfo를 생성하면서 Orderer를 생성하지 않는 경우는 없다.

Aggregate 개념 없는 구조
- ![[KakaoTalk_20231126_130230376.jpg]]

Aggregate 개념 적용 구조

- ![[KakaoTalk_20231126_130230104.jpg]]
- ![[KakaoTalk_20231126_130342837.jpg]]


애그리거트는 경계를 같는다
- "한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다."

애그리거트는 독립된 객체 군이며, 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
- ex) 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등 자기 자신을 관리하지만, 주문 애그리거트에서 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지 않는다.

경계
- 애그리거트 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 사용자 요구사항에 따라 주문 상품 개수와 배송지를 함께 변경하기도 한다. 이렇게 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.
- ex) 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 이들은 한 애그리거틍 속한다.
- ex) OrderLine의 주문 상품 개수를 변경하면 도메인 규칙에 따라 Order의 총 주문 금액을 새로 계산해야 한다.

경계 설정시 주의
- A가 B를 갖는다로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다. 
	- 주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느 정도 타당해 보인다.
- 하지만 A가 B를 갖는다로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.
- ex) 요구 사항 : 상품 상세 정보와 리뷰 내용을 보여주어야 한다.
	- 한 애그리거트에 속한다고 볼 수 있지만 아니다
	- Product와 Review는 함께 생성되지 않고 함꼐 변경되지 않는다.
	- 대신 약하게 연결되어 참조를 할 뿐이다
	- ![[KakaoTalk_20231126_131913380.jpg]]

# 애그리거트 루트

애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져아 한다.
- ex) 구매할 상품의 개수를 변경하면 한 OrderLine의 quantity를 변경하고 더불어 Order의 totalAmounts도 변경해야 한다. 그렇지 않으면 도메인 규칙을 어기고 데이터 일관성이 깨진다.

루트 엔티티 : 애그리거트에 속한 모든 객체가 일관된 상태를 유지하도록 관리하는 주체.
- ex) 주문 애그리거트에서 루트 역할을 하는 엔티티는 Order이다.
- ![[KakaoTalk_20231126_130230376.jpg]]

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.

애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
- ![[KakaoTalk_20231126_132800423.jpg]]

애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
- set이 안 좋은 이유
```java
ShippingInfo si = order.getShippingInfo();

//도메인 규칙을 여기서 검증하면 중복 코드 많아짐

si.setAddress(newAddress);// 도메인 규칙이 적용되지 않고 변경
```


불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음 두가지를 습관적으로 적용해야 한다.
- 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
	- setAddress 접근 불가
- Value 타입은 불변으로 구현한다.
	- si가 불변이기에 setAddress로 수정 불가

"Value 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해섬나 가능하다. 그러므로 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지할 수 있다"


애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

애그리거틑 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.
- ![[KakaoTalk_20231126_133532827.jpg]]
위임을 할 경우 주의
- 애그리거트 루트에서 get 한 후 애그리거트 내부 상태를 변경할 수 있다
- ![[KakaoTalk_20231126_133533190.jpg]]
- "Value를 불변으로 해야하는 이유"
- 패키지 접근자(protected)를 사용하여 외부에서 접근하지 못하도록 막을 수 있어야 한다.




# 트랜잭션

트랜잭션 범위는 작을수록 좋다

DB 테이블을 기준으로 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것은 성능에서 차이가 발생한다.
- 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.
- 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고 이는 전체적인 성능을 떨어뜨린다.

동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정함녀 트랜잭션 충돌이 발생할 가능성이 더 높아지기 떄문이다.

한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다근 것을 의미한다.

애그리거트는 최대한 독립적이어야 한다.

"만약 부득이하게 한 트랜잭션을 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거틀르 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다."
- ![[KakaoTalk_20231126_135756733.jpg]]

도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있는 상황
- 팀 표준 : 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우, DB가 다른 경우.
- 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거틀르 수정해서 일관성을 처리
- UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경 가능

# 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
- ex) Order, OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서 Order와 OrderLine을 위한 리포지터리를 각각 만들지 않는다. Order가 애그리거트 루트이고 OrderLine인 애그리거트에 속하는 구성요소이므로 Order를 위한 리포지터리만 존재

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
- ex) Order 애그리거트와 관련된 테이블이 세 개라면 리포지터리를 통해서 Order 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소를 위한 테이블에 데이터를 저장해야 한다.
```java
// 리포지터리에 애그리거트를 저장하면 애그리거트 전체를 영속화 해야 한다.
orderRepository.save(order)

// 리포지터리는 완전한 order를 제공해야 한다. 내부에 일부 데이터가 누락되거나 하지 않아야 한다.
order = orderRepository.findById(orderId)
```

# ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 달느 애그리거트를 참조한다. 애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과 같다.

하지만 다음과 같이 직접 참조를 하면 안된다.
- ![[KakaoTalk_20231126_140936937.jpg]]
- `order.getOrderer().getMember().getId()`
- JPA를 사용하면 @ManyToNoe, @OneToOne와 같은 어노테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하기에 필드를 이용해서 다른 애그리거트를 참조할 수 있다.


필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다
- 편한 탐색 오용
	- 한 애그리거트에서 다른 애그리거트를 변경할 수 있음 -> 트랜잭션 범위 벗어남.
	- 애그리거트간 결합도가 높아져 애그리거트 구조 변경을 어렵게 함
- 성능에 대한 고민
	- JPA를 사용할 경우 참조한 객체를 지연(lazy) 로딩과 즉시(eager) 로딩의 두 가지 방식으로 로딩할 수 있다.
	- 단순히 연관된 객체의 데이터를 함께 화면에 보여주어야 하면 즉시 로딩이 조회 성능에 유리
	- 상태를 변경하는 기능을 실행하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없으므로 지연 로딩이 유리
- 확장 어려움
	- 하위 도메인마다 서로 다른 DBMS를 사용할 가능성은 높다
	- 이는 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없을 수 도 있다.

애그리거트 참조는 ID를 이용해서 다른 애그리거트를 참조하는 방법이 있다.
- ![[KakaoTalk_20231126_141638196.jpg]]
- DB 외래키 참조 방식과 비슷
- `customer = customerRepository.findBYId(order.getOrderer().getCustomerId()`
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결.
	- 애그리거트의 경계를 명확히 함
	- 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춤
	- 애그리거트 간의 의존을 제거하고 응집도를 높임
- 구현 복잡도 낮아짐
	- 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 됨
	- 참조하는 애그리거트가 필요하면 응용 서비스에서 아이디를 이용해서 로딩
		- 무조건 지연 로딩 아닌가 ?
- 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 방지
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능

N + 1 문제
- ID로 참조하면 조회 속도가 문제될 수 있다.
- ex) 한 DBMS에 데이터가 있다면 조인을 이용해서 한 번에 데이터를 가져올 수 있음에도 불구하고 주문마다 상품 정보를 읽어오는 쿼리를 실행
- 조회 대상이 N개일 떄 N개를 읽어오는 한 번(1)의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행한다.
- ![[KakaoTalk_20231126_142250897.jpg]]

N + 1 문제가 발생하지 않도록 하려면 조인을 사용하도록 해야 한다.
- 별도의 조회 쿼리 사용
- 데이터 조회를 위한 별도 DAO를 만들고 DAO의 조회 메서드에서 세타 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩
- ![[Pasted image 20231126142610.png]]
- 애그리거트마다 서로 다른 저장소를 사용하는 경우에는 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다. 이런 경우 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성.
	- 코드가 복잡해질 수 있지만 시스템의 처리량을 높일 수 있다
	- 트래픽 처리량을 높일때 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법
		- CQRS

# 애그리거트 간 집합 연관(1:N, M:N)

카테고리와 상품 간의 견관이 대표적이다.

개념적으로 존재하는 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과 상관없는 경우가 종종있다.

ex)

- 보통 목록 관련 요구사항은 한 번에 전체 상품을 보여주기보다는 페이징을 이용해서 제품을 나눠서 보여준다.
- ![[KakaoTalk_20231126_143211404.jpg]]
- Category에 속한 모든 Product를 조회하게 된다. 이 코드를 실행할 때마다 실행 속도가 느려질 것이다/

# 애그리거트를 팩토리로 사용

데이터를 추가하는 상황(주문, 상품 등록, ...)에서 도메인 로직으로 검증을 해야하는 경우가 있다.

![[Pasted image 20231126143803.png]]

중요한 도메인 로직이 응용 서비스에 노출되었다

이런 도메인 기능을 넣기 위해 별도의 도메인 서비스나 팩토리 클래스를 만들 수 있지만 더 좋은 방법은 Store 애그리거트에 팩토리 메서드를 추가하는 것이다
- ![[Pasted image 20231126144002.png]]
- ![[Pasted image 20231126144014.png]]
- 서비스에서는 더 이상 Store의 서비스를 검증하지 않는다.

애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려